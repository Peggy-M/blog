# Redis 公平锁与非公平锁

好的，这是一个非常深入且重要的话题。Redis 分布式锁的实现方式直接影响了系统的**公平性、性能和数据一致性**。

首先，要理解“公平”和“非公平”在锁中的含义：

*   **非公平锁**：当锁被释放时，所有正在尝试获取锁的客户端**一起竞争**，谁抢到算谁的。**不讲究先来后到**。优点是**吞吐量高**，缺点是可能导致**某些客户端长时间饥饿**（永远抢不到）。
*   **公平锁**：锁被释放后，应该分配给**等待时间最长**的客户端。**严格遵循先来后到的顺序**。优点是**公平**，缺点是**实现复杂，性能较低**。

---

### 1. Redis 非公平锁 (The Unfair Lock)

这是最常见的实现方式，也就是通常所说的 **“SETNX + Lua”** 方案。它完全是非公平的。

#### 实现原理 (基于 Redlock 算法的基础单实例锁)

```bash
# 加锁：使用 SET 命令的 NX 和 PX 选项
SET lock:order:1234 $unique_value NX PX 30000
# NX: 仅当Key不存在时设置 (Not eXists)
# PX: 设置过期时间，单位毫秒
# $unique_value: 必须是客户端生成的唯一随机值（如UUID），用于安全释放锁。

# 释放锁：使用Lua脚本保证原子性
if redis.call("get", KEYS[1]) == ARGV[1] then
    return redis.call("del", KEYS[1])
else
    return 0
end
```

#### 为什么它是非公平的？

想象一下这个场景：
1.  **客户端A** 持有锁。
2.  **客户端B** 和 **客户端C** 都在不停地重试发送 `SET lock... NX PX ...` 命令来争抢锁。
3.  当**客户端A**的锁过期或被释放的一瞬间，Redis 中的锁 Key 被删除。
4.  就在这一瞬间，**客户端B** 和 **客户端C** 的 `SET` 命令几乎同时到达 Redis。
5.  **Redis 的单线程模型**会顺序处理这两个命令，但**只有一个会成功**。谁的命令先被 Redis 处理，谁就拿到锁。这完全是一个**竞态条件（Race Condition）**，与它们谁先开始等待无关。

**特点：**
*   **优点**：实现简单、性能极高（因为所有客户端都在无差别竞争，没有排队开销）。
*   **缺点**：不公平，可能导致等待时间长的客户端出现“饥饿”现象。

---

### 2. Redis 公平锁 (The Fair Lock)

为了实现公平性，我们需要在 Redis 中模拟一个**排队队列（FIFO Queue）**。最常见的实现方式是使用 **Redis 的 List 结构和发布订阅（Pub/Sub）功能**。

#### 实现原理 (常见方案)

**核心思想**：为每个获取锁的请求创建一个唯一的、顺序的“排队号”，只有拿到最小号（队首）的客户端才能获得锁。

**步骤一：获取排队号**
使用 `LPUSH` 和 `BRPOP` 或 `INCR` 命令来创建一个队列。
```bash
# 方式1：使用List和UUID模拟排队
# 每个客户端在尝试获取锁时，先生成一个UUID，并放入队列末尾
LPUSH lock:order:1234:queue $client_b_uuid
LPUSH lock:order:1234:queue $client_a_uuid
# 现在队列是: [client_a_uuid, client_b_uuid] (LPUSH是头插，所以后放的反而在队列前面)

# 方式2（更优雅）：使用INCR原子计数器生成序列号
# 每个客户端先获取一个全局递增的序列号
INCR lock:order:1234:counter
> 1
INCR lock:order:1234:counter
> 2
```

**步骤二：检查是否轮到自己**
客户端需要检查自己是否位于队列的头部。
```lua
-- 伪代码 Lua 脚本
local mySequence = tonumber(ARGV[1]) -- 我的序列号
local headOfQueue = redis.call('LINDEX', KEYS[1], -1) -- 获取队列的第一个元素（因为是用LPUSH插入的）

if mySequence == tonumber(headOfQueue) then
    -- 轮到我了！尝试获取业务锁
    return redis.call('SET', KEYS[2], ARGV[2], 'NX', 'PX', ARGV[3])
else
    -- 还没轮到，继续等待
    return false
end
```

**步骤三：使用 Pub/Sub 避免忙等待（Busy-Waiting）**
为了避免客户端不停地循环调用步骤二（浪费资源），可以使用 Redis 的发布订阅功能来通知等待的客户端。

1.  当一个客户端释放锁时，它除了删除锁 Key，还会**发布（PUBLISH）一条消息**到一个特定的频道，例如 `lock:order:1234:release`。
2.  其他所有在等待这个锁的客户端都**订阅（SUBSCRIBE）** 了这个频道。
3.  它们一旦收到释放消息，就会**被唤醒**，然后再次执行**步骤二**，检查是否轮到自己了。

#### 为什么它是公平的？
因为它严格维护了一个等待队列。锁总是被授予给**最早进入队列**的那个客户端。后到的客户端必须乖乖排队。

**特点：**
*   **优点**：公平，解决了饥饿问题。
*   **缺点**：
    *   **实现极其复杂**，需要精心处理网络超时、客户端崩溃等问题（例如，一个客户端拿到号后崩溃了，如何从队列中清理它的号？）。
    *   **性能开销大**：需要维护队列，并且使用 Pub/Sub 会创建大量连接和消息。
    *   在分布式环境下，**可靠性挑战更大**。

---

### 对比总结

| 特性           | 非公平锁                                                     | 公平锁                                                       |
| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **实现复杂度** | **低**（几个命令即可）                                       | **极高**（需要队列、序列号、Pub/Sub协同）                    |
| **性能**       | **高**（无额外开销，纯竞争）                                 | **低**（维护队列和消息通知有显著开销）                       |
| **公平性**     | **不公平**（可能饥饿）                                       | **公平**（FIFO，先到先得）                                   |
| **适用场景**   | **绝大多数业务场景**。例如：<br>• 秒杀扣库存<br>• 防止重复处理任务<br>• 对绝对公平性要求不高的临界资源访问 | **对公平性有严格要求的场景**。例如：<br>• 银行交易系统<br>• 票务系统的选座<br>• 稀缺资源的分配 |

### 结论与建议

1.  **默认选择非公平锁**：在 99% 的业务场景中，Redis 非公平锁（标准的 `SET NX PX` + Lua 释放）是**最佳选择**。它的高性能和简单性 outweighs 其不公平性带来的微小影响。所谓的“饥饿”在实际业务中很少成为严重问题。
2.  **谨慎选择公平锁**：除非你有**极其强烈且明确**的公平性需求，否则不要轻易尝试自己实现一个基于 Redis 的公平分布式锁。其复杂度非常高，很容易引入新的 Bug 和稳定性问题。
3.  **考虑其他工具**：如果你确实需要强一致且公平的分布式锁，或许应该考虑使用 **ZooKeeper** 或 **etcd** 这类**一致性协调系统**。它们通过**临时顺序节点（Ephemeral Sequential ZNode）** 可以更原生、更可靠地实现公平锁（每个节点监听它前面的节点即可）。虽然它们的性能通常低于 Redis，但为分布式协调而生，提供了更强大的基础语义。

**总而言之，对于 Redis，你几乎总是在使用一个高性能的非公平锁。** 认识到这一点，对于理解你的系统在高并发下的行为至关重要。