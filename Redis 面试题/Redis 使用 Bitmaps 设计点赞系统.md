### 一、设计思路

核心思想：**为每个被点赞的对象（如一条微博、一篇文章、一个视频）创建一个 Bitmap。这个 Bitmap 的每一个位（bit）代表一个用户是否点赞。位的偏移量（offset）就是用户的唯一 ID（例如 `user_id`）。**

- **Key 的设计**： `like:target_type:target_id`
  - 例如：`like:post:1001` 表示 ID 为 1001 的帖子对应的点赞 Bitmap。
  - 例如：`like:comment:2005` 表示 ID 为 2005 的评论对应的点赞 Bitmap。
- **Value**： 一个巨大的二进制位数组（Bitmap）。
- **操作**：
  - 用户（`user_id = 100`）点赞：将 `like:post:1001` 这个 key 对应的 Bitmap 中偏移量为 100 的位设置为 1。
  - 用户取消点赞：将对应位设置为 0。
  - 检查用户是否点赞：检查对应位是 1 还是 0。
  - 获取总点赞数：计算整个 Bitmap 中值为 1 的位的数量（BITCOUNT）。
  - 判断多个用户是否点赞：一次性获取多个位的状态。

### 二、Redis Bitmap 核心命令

1. **SETBIT**： 设置指定偏移量的位的值（0 或 1）
   - `SETBIT key offset value`
   - 示例：`SETBIT like:post:1001 100 1` （用户 100 点赞了帖子 1001）
2. **GETBIT**： 获取指定偏移量的位的值
   - `GETBIT key offset`
   - 示例：`GETBIT like:post:1001 100` （返回 1，表示用户 100 已点赞）
3. **BITCOUNT**： 计算整个 Bitmap 或指定字节范围内，值为 1 的位的数量
   - `BITCOUNT key [start end]`
   - 示例：`BITCOUNT like:post:1001` （返回帖子 1001 的总点赞数）
4. **BITOP**： 对多个 Bitmap 进行位运算（AND, OR, XOR, NOT）
   - 示例：找出同时点赞了帖子 1001 和帖子 1002 的用户（`BITOP AND result_key like:post:1001 like:post:1002`，然后再对 `result_key` 进行 `BITCOUNT` 或遍历）。

### 三、传统方案

**使用 Set（集合）**

这是最直观和常见的传统方案。

**设计思路：**

- 为每个被点赞的对象创建一个 Set
- Set 中存储所有点赞用户的 ID

**Key 设计：** `like:target_type:target_id`（与 Bitmap 相同）

**操作：**

- **用户点赞**：`SADD like:post:1001 user_id`
- **用户取消点赞**：`SREM like:post:1001 user_id`
- **检查用户是否点赞**：`SISMEMBER like:post:1001 user_id`
- **获取总点赞数**：`SCARD like:post:1001`
- **获取所有点赞用户**：`SMEMBERS like:post:1001`



### BitMap 的偏移量上限限制

Redis Bitmap 的偏移量（offset）使用 **无符号 64 位整数**，所以最大偏移量是：

**2³² - 1 = 4,294,967,295**（约 42.9 亿）也就是说，用户的 id 最大是 为 **4294967295** 超出这个数就会无法执行



## 传统方案 vs Bitmap 方案对比

| 特性             | Bitmap 方案          | Set 方案                   | Hash 方案      | Sorted Set 方案 |
| :--------------- | :------------------- | :------------------------- | :------------- | :-------------- |
| **内存效率**     | ⭐⭐⭐⭐⭐ (极高)         | ⭐⭐ (一般)                  | ⭐⭐ (一般)      | ⭐⭐ (一般)       |
| **查询速度**     | ⭐⭐⭐⭐⭐ (极快)         | ⭐⭐⭐⭐ (快)                  | ⭐⭐⭐⭐ (快)      | ⭐⭐⭐ (较快)      |
| **存储元数据**   | ❌ 不支持             | ❌ 不支持                   | ✅ 支持         | ✅ 支持          |
| **排序功能**     | ❌ 不支持             | ❌ 不支持                   | ❌ 不支持       | ✅ 支持          |
| **用户ID类型**   | ❌ 必须为数字         | ✅ 任意类型                 | ✅ 任意类型     | ✅ 任意类型      |
| **获取所有用户** | ❌ 效率极低           | ✅ 效率高                   | ✅ 效率高       | ✅ 效率高        |
| **共同点赞计算** | ✅ 位运算高效         | ⚠️ 集合运算                 | ❌ 不支持       | ❌ 不支持        |
| **适用场景**     | 海量用户、纯状态记录 | 中小规模、需要获取用户列表 | 需要存储元数据 | 需要时间排序    |