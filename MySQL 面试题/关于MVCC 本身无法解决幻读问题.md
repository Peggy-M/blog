# 关于MVCC 本身无法解决幻读问题

### 1. MVCC 的作用

MVCC 的核心思想是：

- 读操作不阻塞写操作，写操作也不阻塞读操作。
- 每个事务读取数据时，会读取一个快照（Snapshot），而不是直接读“当前最新版本”。
- 这样就避免了：
  - **脏读**（读到未提交事务的数据）
  - **不可重复读**（同一事务两次读同一条记录，结果不一样）

------

### 2. 幻读是什么

幻读发生在事务中执行了**范围查询**时：

- 事务 T1：`SELECT * FROM orders WHERE amount > 100;`
- 事务 T2：插入一条 `amount=200` 的记录并提交。
- 事务 T1 再次执行相同的 `SELECT`，发现多了一行数据。

这种“多出或减少的行”就是 **幻读**。

------

### 3. 为什么 MVCC 解决不了幻读

因为 MVCC 的快照**针对的是已存在的记录**，它能保证一行数据在事务期间保持一致；
 但对于**新增的行**，它是无法阻止的。

- 比如事务 T2 插入了新行，T1 的快照里本来没有，等到 T1 再查询，发现“出现了一行幻影”。

所以单靠 MVCC，只能解决“行内容变动”带来的问题，但解决不了“行集合发生变化”的情况。

------

### 4. 解决幻读的方法

数据库一般有两种方式：

1. **可重复读 + Next-Key Lock（间隙锁）**
   - InnoDB 在 **REPEATABLE READ** 隔离级别下，如果涉及范围查询，就会加 **Next-Key Lock**，锁住数据范围，不允许别的事务往这个范围里插入新行，从而避免幻读。
2. **Serializable 隔离级别**
   - 把所有的读都当成写来处理，事务之间完全串行化执行，彻底避免幻读，但并发性能最差。

### 5. 什么是间隙锁（Gap Lock）

- 普通行锁：锁住某一行记录（比如 id=10）。
- **间隙锁**：锁住某一行“之间的空隙”（比如 (10,20) 这个范围），防止别的事务在这个范围里插入新行。
- **Next-Key Lock** = 行锁 + 间隙锁。

它的作用就是：**防止幻读**。

### 6.在什么情况下 InnoDB 会加间隙锁

1. **事务隔离级别必须是 REPEATABLE READ 或更高（Serializable）**

   - 在 READ COMMITTED 下，间隙锁一般不会生效。

2. **执行范围查询时**
    例如：

   ```
   BEGIN;
   SELECT * FROM users WHERE age BETWEEN 10 AND 20 FOR UPDATE;
   ```

   这时 InnoDB 会锁住 `age` 在 (10,20) 区间的已有行，并且加上 **间隙锁**，禁止别的事务在这个范围插入新的 age=15 的用户。

3. **唯一索引失效时**
    如果条件不是精确等值查询，而是范围、模糊或者没有用上索引，也会触发间隙锁。

### 7. 如何“添加”间隙锁（实操）

👉 关键是 **语句 + 事务隔离级别**。

### 例子：防止幻读

对的 ✅，你写的这三行确实可以触发 **间隙锁（Gap Lock）**，但有几个细节要注意，我给你完整解释一下：

**你的语句做了什么**

```sql
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;
SELECT * FROM orders WHERE amount > 100 FOR UPDATE;
```

- `SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;`
   设置本会话的隔离级别为 **可重复读**。这是 InnoDB 触发间隙锁的前提。
- `BEGIN;`
   开启一个事务。
- `SELECT * FROM orders WHERE amount > 100 FOR UPDATE;`
   这是一个**范围查询** + **锁定读**。
   InnoDB 会：
  - 锁住所有 `amount > 100` 的已有行（行锁）。
  - 在这些行的“间隙”上加 **间隙锁**，防止其他事务插入 `amount` 在范围内的新记录。

**什么时候触发间隙锁**

你的语句可以触发，但要满足几个条件：

1. **必须有索引**：
   - 如果 `amount` 上有索引（最好是 B+树索引），就能精确地在索引范围上加 gap lock。
   - 如果没有索引，InnoDB 会锁整张表（全表扫描 + 意外的大范围间隙锁）。
2. **必须是范围查询**：
   - `>`, `<`, `BETWEEN`，这些会触发间隙锁。
   - 精确匹配（`WHERE amount = 100` 且有唯一索引）不会触发间隙锁，只会锁行。
3. **隔离级别是 REPEATABLE READ**：
   - 在 READ COMMITTED 下，大部分情况下不会加 gap lock。

### 8. 手动验证间隙锁是否生效

1. 查看事务信息：

   ```
   SELECT * FROM information_schema.innodb_locks;
   ```

2. 你会看到锁的类型里出现 `GAP` 或 `NEXT-KEY`。