# 范围查询中断索引使用

有两条执行的 SQL 分别是第一条命中了，建立的三条索引，而第二条只命中了前两条索引

~~~ sql
#其实该条 SQL 语句之所以可以命中三条记录，主要是因为存在一个等值查询，该等值条件之下本来是就是有序的所以可以根据索引继续查询 customer_id 字段，但对于 inventory_id > 10 的部分是无法进行命中的 
explain  select rental_id,staff_id from rental where rental_date = '2005-05-25' and inventory_id > =10 and customer_id = 130;

explain  select rental_id,staff_id from rental where rental_date = '2005-05-25' and inventory_id > 10 and customer_id = 130;
~~~



假设你有一个联合索引 `idx_rental_date_inventory_id_customer_id (rental_date, inventory_id, customer_id)`。

- **索引的结构**：这个索引首先按 `rental_date` 排序，在 `rental_date` 相同的记录组内，再按 `inventory_id` 排序，在 `inventory_id` 也相同的记录组内，最后按 `customer_id` 排序。

#### 对于第一个查询：`inventory_id >= 10`

sql

```
SELECT ... WHERE rental_date = '2005-05-25' AND inventory_id >= 10 AND customer_id = 130;
```



1. **`rental_date = '2005-05-25'`**：这是一个**等值查询**。索引首先定位到所有 `rental_date` 为 ‘2005-05-25’ 的记录。此时，在这个日期组内，记录是按 `inventory_id` 有序排列的。
2. **`inventory_id >= 10`**：这是一个**范围查询**。数据库可以在上一步筛选出的日期组内，快速找到 `inventory_id >= 10` 的记录。**关键在于**：对于 `inventory_id = 10` 的记录，它们内部仍然是按 `customer_id` 有序排列的。
3. **`customer_id = 130`**：由于上一步的范围查询包含了等值（`inventory_id = 10`），数据库可以在所有 `inventory_id = 10` 的记录里，继续利用索引的有序性来快速查找 `customer_id = 130` 的记录。**对于 `inventory_id > 10` 的部分，`customer_id` 的索引失效了，但因为 `inventory_id = 10` 这个“等值点”存在，优化器仍然认为使用索引来过滤 `customer_id` 是值得的，所以执行计划会显示三个字段都命中了。**

#### 对于第二个查询：`inventory_id > 10`

sql

```
SELECT ... WHERE rental_date = '2005-05-25' AND inventory_id > 10 AND customer_id = 130;
```



1. **`rental_date = '2005-05-25'`**：同上，等值查询，定位到日期组。
2. **`inventory_id > 10`**：这是一个**纯粹的范围查询**（“大于”，不包含等于）。数据库找到所有 `inventory_id > 10` 的记录。
3. **`customer_id = 130`**：**问题就在这里！** 对于所有满足 `inventory_id > 10` 的记录，`inventory_id` 的值是一个**范围**（11, 12, 13, ...）。在这个范围内，`customer_id` 的存储是**无序的**（因为索引的先序列是 `inventory_id`，它的值一直在变）。因此，数据库**无法再有效地使用索引来快速定位 `customer_id = 130`**。
   - 它只能扫描所有 `inventory_id > 10` 的记录，然后逐条对比它们的 `customer_id` 是否等于 130。
   - 从索引的角度看，`customer_id` 这个索引列在此查询中**失效**了。过滤 `customer_id` 的操作是在从索引记录中取出数据后，在服务器层完成的（可能会显示为 `Using where`）。

------

### 如何通过 `EXPLAIN` 结果验证

- **第一个查询 (`>=`) 的 `EXPLAIN` 输出可能显示：**
  - `key_len`: 一个较大的值，表示索引中三个字段的长度都被用到了。
  - `type`: `range`
  - `Extra`: `Using index condition` (如果支持ICP)
- **第二个查询 (`>`) 的 `EXPLAIN` 输出可能显示：**
  - `key_len`: 一个较小的值，只计算了 `rental_date` 和 `inventory_id` 两个字段的长度。
  - `type`: `range` (仍然是因为 `inventory_id > 10`)
  - `Extra`: **`Using where`** —— 这就是关键证据！它表明 `customer_id = 130` 这个条件是在引擎层返回索引数据后，在服务器层进行过滤的，而不是在索引层面完成的。