## 并发编程完整版本之线程池

### 前言

在实际的一些业务开发当中，对于一些较大的的任务，可能会使用到多线程并发异步拆分，汇总去处理一些业务上的问题，比如，对于一个业务可能会同时设计到 SQL 的查询，数据的计算，文件的 I/O，以及远程服务的调度等，这些业务可能是没有强联系的，就可以通过线程异步并发执行，来提高执行的效率缩短客户端的响应时间。

但如果对于这些业务，在开发当中频繁的业务的线程对象进行创建&销毁，这个过程当中需要频繁的进行栈内存的分配，这样会对**系统产生额外的开销**，以及在业务的处理过程当中，到底线程处理了多少个任务以及每一个线程所占用的**系统资源开销是无法进行统计和管理的**， 也同时可能由于编码人员的专业能力可能会编码出隐藏的 bug 导致**线程个数爆**炸这样的风险。

因此，为了解决上述出现的一系列让人头疼的问题，让开放者更加专注于业务的整体逻辑，而并非是对线程的管理，就急需要一种可以做到 **统一管理集中管理监控线程的工具** ，也就是*<u>**线程池**</u>* 。线程池可以让开发者从让开发者不再花费更多的精力去管理线程的创建&销毁以及线程使用不当，导致线程数量爆炸等极端情况，更高的关注于业务层面。

### JDK 当中自带线程工厂方法

并发大师 Doug Lea 在 JDK 1.5 当中针对于不同的需要引入了不同的线程池对象，接下来将一一介绍这些这些 JDK 自带的线程池工具。

#### **newFixedThreadPool 创建固定大小的线程池** 

~~~ java
public void fixedThreadPoolMax(Boolean isShutDown) {
    ExecutorService executorService = Executors.newFixedThreadPool(200);
    for (int i = 0; i < 200; i++) {
        executorService.execute(ThreadPoolExecutorExample::printf);
    }
    //这里如果不执行 shutdown 就不会被回收
    if (isShutDown) executorService.shutdown();
}
~~~

~~~ java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
~~~

~~~ java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}
~~~

通过底层源码可以看出，在调用 `newFixedThreadPool ` 之后会返回一个 `ThreadPoolExecutor` 对象，其主要返回的了一个 `ThreadPoolExecutor` 线程池对象，如果不通过 `newFixedThreadPool` 方法调用，而是直接通过`ThreadPoolExecutor` 创建对象，其效果也是一样的，可以理解为 `newFixedThreadPool` 是对 `ThreadPoolExecutor` 对象创建的一种封装。

可以看到的底层是使用了 ` LinkedBlockingQueue<Runnable>()` 链表队列来存储 `Runnable ` 线程任务的,这里需要注意的是这些给定的线程池大小，线程在一开始并不会被全部初始化创建好，而是在执行 `execute` 方法的时候会懒加载创建 `Thread` 对象，并且在使用完线程池资源之后需要执行 `shutdown` 关闭线程池。

#### **newSingleThreadExecutor 创建一个单例的线程池**

~~~ java
public void singleThreadExecutor() {
    ExecutorService executorService = Executors.newSingleThreadExecutor();
    executorService.execute(ThreadPoolExecutorExample::printf1);
    executorService.execute(ThreadPoolExecutorExample::printf2);
    executorService.execute(ThreadPoolExecutorExample::printf3);
}
~~~

~~~ java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
~~~

~~~ java
static class FinalizableDelegatedExecutorService
    extends DelegatedExecutorService {
    FinalizableDelegatedExecutorService(ExecutorService executor) {
        super(executor);
    }
    // finalize 当前对象被 GC 回收之前，执行的方法。因此不需要自己主动调用 shutdown 关闭线程池
    protected void finalize() {
        super.shutdown(); 
        // finalize 在执行时，是守护线程，守护线程无法保证一定可以执行完毕，因此在使用的时候如果一个线程池是基于业务构建的，在使用完毕之后一定要手动的执行 shoutdow 关闭线程池
    }
}
~~~

`newSingleThreadExecutor `从名字就可以看到返回的是一个单线程线程池，从源码可以看到在创建线程池对象的时候初始化就给的了最大线程数与核心线程数都为 1 ，这种线程对象一般是使用在 **日志顺序处理** 、**消息顺序消费** 等，可以看到始终都是只有一个线程对象，所以当任务投递过来之后第一个任务会被工作线程处理，后续的任务会被放入到工作队列当中，任务的执行会按照顺序执行。

#### **newCachedThreadPool 非核心线程空闲存活时间 **

~~~ java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
~~~

~~~ java
//等待工作的空闲线程的超时（以纳秒为单位）。当存在超过 corePoolSize 或 allowCoreThreadTimeOut 时，线程将使用此超时。否则，他们将永远等待新的工作。   
private volatile long keepAliveTime;
~~~

从构造方法可以看到，最大的线程数是 `Integer.MAX_VALUE` ，所以只要提交任务就会立即被执行而不会被阻塞，任务队列是一个 `SynchronousQueue` 因此也决定了其底层的特性是，不存储阻塞任何的任务，同时有多少个任务就有多少个线程池对象。当前线程数大于等于核心线程数时，当线程的空闲时间超过指定的 `keepAliveTime`  ,该线程就会被终止，直到当前线程数 = `corePoolSize`

- 特殊配置

~~~ java
// 允许回收核心线程
executor.allowCoreThreadTimeOut(true);
// 此时corePoolSize的线程空闲超过keepAliveTime也会被回收
~~~

一般来说，这种线程池可以用于对于短时间内突然激增的高并发的场景，比如 **电商的限时秒杀场景** ，在突发流量一定时间之后，这些线程就会被回收。

#### **newScheduledThreadPool 定时任务线程池**

~~~ java
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
~~~

~~~ java
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          //基于延时队列实现的线程池,周期性是在执行完成之后再次丢回到阻塞队列当中
          new DelayedWorkQueue());
}
~~~

~~~ java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}
~~~

- 调用定时方法

~~~ java
public void scheduledThread() {
        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
        System.out.println("开始执行的时间:--> " + new Date());
        scheduledThreadPool.schedule(() -> {
            ThreadPoolExecutorExample.delayTask(1, 1);
        }, 1, TimeUnit.SECONDS);

        scheduledThreadPool.schedule(() -> {
            ThreadPoolExecutorExample.delayTask(2, 5);
        }, 5, TimeUnit.SECONDS);

        scheduledThreadPool.schedule(() -> {
            ThreadPoolExecutorExample.delayTask(3, 10);
        }, 10, TimeUnit.SECONDS);
        System.out.println("执行结束的时间:--> " + new Date());

        scheduledThreadPool.scheduleAtFixedRate(() -> {
            ThreadPoolExecutorExample.delayTask(4, 3);
        }, 3, 5, TimeUnit.SECONDS);
        System.out.println("执行结束的时间:--> " + new Date());
    }
~~~

`newScheduledThreadPool ` 是一个定时任务的线程池，同样给定的最大线程数与前面的 `newCachedThreadPool` 空闲线程回收的线程池是一样的，都是 `Interage.MAX_VALUE` ,区别在于 `ScheduledThreadPoolExecutor` 基础了 `ThreadPoolExecutor` 类，对原有的线程池对象的功能进行了扩展。

~~~ java
public ScheduledFuture<?> schedule(Runnable command,
                                   long delay, TimeUnit unit);
~~~

这里的 `delay` 延时参数，是指定从现在开始执行的延时时间，也就是说这个计时是从任务提交的时候就已经开始计时了，假设延时10秒，一个任务执行时间是 3 s ，而提交之后阻塞了5秒，那这个任务实际是被延时了 5 秒执行。

同时还提供了一个定期延时执行的函数方法 `scheduleAtFixedRate` 其中多了一个 `period` 执行时间间隔的参数。

~~~ java
public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit);
~~~

#### **newWorkStealingPool工作窃取的线程池**

在说明 `newWorkStealingPool` 之前，可能需要先了解一下 **工作窃取** 这种算法的底层思想，工作窃取简单来说，其实就是 **当前自己的工作做完之后，就去看看别人的工资是否做完，如果有就将被人工作拿过来帮他处理完**

底层的核心算法思想是，***为每一个工作者分配了一个双端队列用于存储需要执行的任务，当前自己本地无工作任务的失败，就会去窃取其他的工作线程尚未处理完成的任务***

`newWorkStealingPool` 处理了使用前面提到的 **工作窃取** 这种思想，在这个基础之上使用分而治之进行任务拆分。

~~~ java
public void workStealingThread() {
    Integer[] maxArray = new Integer[100_000_000];
    System.out.println("开始时间:--> " + new Date());
    for (int i = 0; i < maxArray.length; i++) {
        maxArray[i] = i * 1000;
    }
    System.out.println("结束时间:--> " + new Date());

    ForkJoinPool forkJoinPool = new ForkJoinPool(); // 工作窃取池的底层实现
    System.out.println("============================================================================");
    System.out.println("开始时间:--> " + new Date());
    long result = forkJoinPool.invoke(new SumTask(maxArray, 0, maxArray.length));
    System.out.println("结束时间:--> " + new Date());
}
~~~

~~~ java
class SumTask extends RecursiveTask<Long> {
    private final Integer[] array;
    private final int start;
    private final int end;
    private static final int THRESHOLD = 10_000; // 阈值

    SumTask(Integer[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if (end - start <= THRESHOLD) {
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += (long) array[i] * array[i];
            }
            return sum;
        } else {
            int mid = (start + end) / 2;
            SumTask left = new SumTask(array, start, mid);
            SumTask right = new SumTask(array, mid, end);
            left.fork(); // 异步执行左半部分
            return right.compute() + left.join(); // 合并结果
        }
    }
}
~~~

